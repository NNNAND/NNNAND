# C++

## 程序内存模型

### 栈区

您尝试返回一个局部变量 `a` 的地址。局部变量的生命周期仅限于函数执行期间，一旦函数结束，局部变量就会被销毁，因此返回局部变量的地址是危险的，因为该地址可能指向已经无效的内存。

形参也会放在栈区

### 堆区

我们来管理这个区，在程序运行时，不会关闭但是程序结束后操作系统会回收内存。

利用new关键字可以将数据开辟到堆区；指针本质也是局部变量，放在栈上，指针保存的数据放在堆区；

### new操作符

```c++
//在数据放在堆区，new返回的数据类型指针。
int * p = new int(10);
//利用delete释放
delete p;
void test(){
  //创建一个十个整型的数据。
  int * arr = new int[10]; 
  for(int i = 0; i<10; i++){
    arr[i] = i +100;
  }
}
//释放堆区数组,要加中括号。
delete[] arr;
  
```

## 引用
```c++
//数据类型 &别名 = 原名
int a = 10;
int &b = 10;//引用
cout << b << endl;
```
==引用的注意事项==
引用必须初始化。	`int &b;`错误
引用初始化后就不可改了。这就是指针常量的特点指向不可改。

### 引用做函数参数

```c++
swap(&a,&b);
swap(int *a, int *b){}
//引用传递 别名和原名一样可以
swap(a, b)
swap(int &a, int &b){}
```

### 引用做函数返回值

```c++
//不要返回局部变量的引用
int& ref(){}
int &ref = ref();
//函数的调用可以作为左值 前提是这个函数的返回值是引用。
ref() = 1000;
```

==引用的本质==在c++中内部实现是一个==指针常量==。`int * const p = &a;`指向不可以改，`p = &a`不被允许但是还可以`*p = 20`

常量指针：值不可以改 `const int * p = &a;`但是那个指向可以改 `p = &a;`被允许。

==指针的解引用==*p 得到对应地址存放的数据。

编译器帮我们做了在引用的过程中。* ref

### 常量引用

==作用==：主要用来修饰形参，防止误操作。

常量引用 `const int &ref = 10;`

```c++
showValue(const int &val){
  //修改是不能的
  val = 100; //会报错
}
showValue(a);
```

## 函数的提高

### 函数的默认参数

==传了参数还得用我的 函数名(参数1)==，没有用默认值

==如果有默认参数，那么默认参数得是最后一个。他后面没有默认参数会报错==

==如果函数的声明有默认参数，函数的实现就不能有默认参数。不能同时实现默认参数==

```c++
//返回值类型 函数名 (参数=默认值,参数2=默认值){}
//如果我传了参数还得用我的 函数名(参数1)

```

### 函数的占位参数

==只给参数类型，不给实际的代表==

占位参数还可以有默认参数

### 函数重载

作用：函数名相同，提高复用性

==函数重载满足条件：==

- 同一作用域
- 函数名相同
- 函数参数类型，个数，顺序不同

### 函数重载的注意事项

1. 引用作为重载条件
2. 函数重载碰到默认参数

```c++
void func(int &a){}
void fun(const int &a){}
int a = 10;
func(a); //会调用第一个
func(10); //会调第二个
func(int a, int b = 10){}
func(int a){}
func(10); //报错，会导致二义性

```

## 类和对象

```c++
const double PI = 3.14;
class Circle{
public:
  int R = 3;
  double calculateZC(){
    return 2 * PI * R;
  }
}
```

## 封装

### 访问权限

public 类内可以访问	类外可以访问

protected 类内可以访问	类外不可访问	子可以访问父亲中的保护内容

private 类内可以访问	类外不可访问	子不可访问父亲私有内容

### struct和class的区别

==唯一区别：==**<u>默认访问权限不同</u>。**

struct：public

class：private

### 成员属性设置为私有

<u>可以自己控制读写权限</u>

对于写权限，<u>我们可以检测数据的有效性</u>

## 对象的初始化和清理

### 构造函数和析构函数

``类名(){}``

<u>构造函数可以有参数所以的重载</u>

``~类名(){}``

<u>不可以有参数</u>

构造函数的分类 <u>有参和无参（默认）</u>	<u>拷贝构造和普通构造</u>

```c++
//拷贝构造函数
Person(const Person &p){
  age = p.age;
}
```

```c++
//括号法调用
Person p1;//无参
Person p2(10);//有参
Person p3(p2);//拷贝
//注意无参的，下面这行代码编译器会认为是一个函数的声明
Person p1();

//显示法
Person p1;
Person p2 = Person(10);
Person p3 = Person(p2);
Person(10); //匿名对象 特点当前执行结束时，系统会立即回收
注意//编译器会认为 Person(p3) === Person p3; 对象声明
  
//隐式转化法
person p3 = 10;//相当于 Person p3 = Person(10);
Person p4 = p3;
```

